作为一个开源的应用容器引擎，docker可以让开发者直接将其中的应用和依赖装到容器中，然后发布到任何流行的linux上，也可以实现虚拟化。



《与虚拟机的大同小异》

Docker的容器技术和虚拟机技术都同时采用了虚拟化技术（该技术将物理硬件资源分成多个虚拟实体，在这些虚拟实体上独立运行操作系统和应用程序，实现资源的共享、抽象和模拟），而不同点则是相较于虚拟机技术有三层抽象层，Docker容器技术少了一个Guest OS(客户操作系统），使得Docker能够直接使用实际的物理计的硬件资源，达到更高的效率（说白了就是尺寸更小、开启更快、开发更方便、支持范围更广）

But,像是日志、数据库等一般放在Docker以外，而自身只用于计算，存储交给挂载。

补充：Guest OS 是指虚拟化环境中运行的操作系统，依赖于Host OS(宿主操作系统）和Hypervisor（虚拟机监控器）来访问硬件资源。Guest OS 可以是任何操作系统，只要它能在虚拟化平台上运行。



接下来在下载docker的过程可谓是一波三折，我先从官网按步骤来

结果在下载一部分依赖包之后系统更新时碰见了这

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760779008558-27eca272-9eb8-4931-bfa2-b9a97ed3bb4a.jpeg)

被锁住了，我用kill结束进程后，再次更新，结果一直卡住

我中间多次重启，发现一直是这样，我按指示等待片刻，让锁自己结束占用。

结果快二十分钟还是不可以，于是我直接把锁去了

```plain
sudo rm /var/lib/apt/lists/lock
sudo rm /var/cache/apt/archives/lock
```

与此同时，我也将原来的源替换成中科大的源

接下来正常安装



但是，在安装之后进行调试时又error了

经过上网，我了解到这是国内源登国外镜像过慢导致的。

又折腾了一个小时，我从群友的资料中找到最简单的流程，给docker挂了个梯子，这才成功运行了docker，花了六七个小时才弄好，学辅也在帮我，但最终计算机在经过几次重启后才换好源，使我能够pull镜像，hhhhh,苦尽甘来。



镜像是一种文件存储形式，通常指磁盘上的的数据在另一个磁盘上存在一个完全相同的副本，同时操作系统、应用程序也可成为镜像。镜像就是一个只能读的模板，包含着运行某个软件所需的内容（代码、运行时的环境、环境变量、配置文件等等）以此作为创建容器的基础。

容器是镜像的运行实例。在提供一个独立、安全的运行环境之后，我们可以对运行中的容器进行修改，是真正运行应用程序的地方。（一个底层镜像可以有多个容器运行）

仓库是集中存放镜像的地方，其实也是最好理解的，你可以上传镜像，也可以从中下载镜像为自己所用。

```plain
docker pull ubuntu:22.04
```

这就是下载一个镜像。



分层镜像指的是镜像划分成多个只读层来实行存储效果，可以理解成一层层的原料，每一层都对应镜像的一次修改，包括基础系统层，多个镜像可以共享底层资源，而且容器启动时不会影响底层的镜像。



《基本代码》

简单的关于docker自身的检索

```plain
docker version 
docker info 
```

以及有关镜像的命令

```plain
docker images  #查看镜像
docker serach   #搜索镜像
docker pull  xxxxxx   #下载镜像
docker rmi  xxxxxxx #删除
docker commit -a "xxx" -c "xxx" 镜像  名字：版本  #提交
docker load -i   /xxx/xxx.tar  #导入
docker save -o   /xxx/xxx.tar  #导出
```

镜像的导入就是指将本地或外部的镜像源引入云计算平台或容器管理工具的过程。借此可以快速创建具有相同软件环境的虚拟机或容器



```plain
docker run [参数] image 命令  #启动容器
docker build   #创建镜像
docker logs  #获取日志输出
docker ps （-a）  #查看容器（所有）
docker rm  #删除
docker kill  #结束
docker attach/exec  #进入容器 前者中断会使容器退出，后者不会，同时前者加入运行中的容器，后者新开一个
exit #直接退出容器
crtl + p +q  #退出但不终止
```



此外，还有一些命令例如history(查看历史）、start（开始）、restart(重启）等等基础命令



《数据卷的使用》

docker容器产生数据是，如果不通过commmit生成新的镜像，当容器删除后，数据也会消失，而“数据卷”就是为了是数据持久化，完全独立与容器的生存周期。

1、数据卷可在容器之间共享或者重用数据。

2、卷中的更改可以直接生效。

3、数据卷中的更改不会包含在镜像的更新中。

4、数据卷的生命周期一直持续到没有容器使用它为止

```plain
docker run -it -v 主机目录：容器目录
```

例如在/home/中/home/test01即可新加一个test01

在容器中的修改会同步到主机的home当中



《Dockerfile》

作为一个文本文件，它版含量一系列指令和参数，用于定义如何构建一个特定的docker镜像。

结构分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时的指令，每行一条指令，每个指令可带多个参数，支持#作为注释（类似python的注释方式）

编写时，第一行必须使用FROM指明所基于的镜像名称，之后用MAINTAINER说明维护该镜像的用户信息，然后是镜像操作的相关指令，每运行一行，都会给基础镜像添加新的一层指令，最后用CMD指定启动时所需的命令。

```plain
docker pull centos #先拉取基础镜像
mkdir xxxxxxx  
cd  xxxxxx  #建立工作目录
vim Dockerfile #创建并编写
FROM centos:latest  #指明基础镜像
LABEL The CentOS Project  #维护该镜像的用户信息
Run yum -y update
-------------
------------  #命令
EXPOSE xx  #开启端口
CMD ["/usr/sbin/sshd","-D"]  #启动的指令
docker build -t sshd:new  #生成镜像
docker run -d -P sshd:new  #启动容器
ssh localhost -p 66666//输入密码即可  #修改密码
```

这就是一个例子

相关命令有ENV（设置环境变量）COPY（拷贝文件到镜像）VOLUME（设置卷，挂载主机的目录）等等，现在不太熟练，之后会练习的

而自定义镜像就是在本地开设一个文件，并附加内容，通过COPY到其中，以便自己能够及时修改和不用反复套用，类似于数据卷的使用。



《端口映射》

前文已经说容器运行在独立的虚拟网络空间中，与宿主机隔离

这就是使得容器有自己的IP地址，无法被宿主机直接访问，需要通过端口映射或网络模式配置实现转发。

-p参数用于将宿主机端口与容器内部端口绑定

比如启动nginx容器并映射端口

docker run -d -p 8080:80 nginx：latest

意思是说宿主机外部访问https://宿主机IP8080时，流量会被转发到容器80端口，从而访问nginx服务。



《dockerhub》

搜索镜像有两种方法，进官网直接搜索镜像名称 | 命令行用search命令搜索

拉取镜像docker pull 镜像名：标签

登陆dockerhub跟github一样，我直接用相同的邮箱和名字了,之后正常搜索拉取镜像就行了

