![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1761476681321-cea8291a-d14d-456f-9f8a-8581f89e755c.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1761476682479-b6afe144-58ac-4d76-a7d7-ee430dc5c801.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1761476684624-d305edbb-fb4b-4a24-b9ac-b378edf5fbf9.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1761476685111-135764f2-8737-4a57-8c09-d29fde587158.jpeg)

其实本周的任务按照视频教程里环节一步步推导是很顺畅的,我也逐渐理解到一些命名的方式不能太随意

本周的任务整体上分为,

视频的读取\

信号灯的颜色检测\

信号灯的颜色标注\

文字信息的呈现\

视频的输出\

但是,在实际操作中我发现我的电脑会将图片\视频大型化,(不过我认为是视频的问题),例如

![](https://cdn.nlark.com/yuque/0/2025/png/61445279/1761477137266-c77ab4ed-882e-4950-886c-e4f0d2ab8343.png)

!这是我整个屏幕,只能呈现它的一角,所以我得指定生成视频的尺寸和帧率

视频的读取相当轻松,

   VideoCapture cap("TrafficLight.mp4");

但是由于我的电脑好像没有安装视频播放器,导致我在桌面上无法直接打开,只能将picture文件夹加入vscode才行



接下来是信号灯的颜色

    Scalar lower_red = Scalar(0, 120, 70);

    Scalar upper_red = Scalar(10, 255, 255);

    Scalar lower_green = Scalar(35, 120, 70);

    Scalar upper_green = Scalar(77, 255, 255);

对了这里的参数是我调整前的数据,超级超级难,这个绿色的信号本来在调试中一直不出来,将upper的值增大后,红色的信号也被识别成绿色,又得调小.

        cvtColor(resized_frame, hsv, COLOR_BGR2HSV);



        Mat red_mask;

        inRange(hsv, lower_red, upper_red, red_mask);



        Mat green_mask;

        inRange(hsv, lower_green, upper_green, green_mask);

这个就是圈定范围的,用二值化掩玛阈值



位置上,

 vector<vector<Point>> red_contours, green_contours;

        findContours(red_mask, red_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        findContours(green_mask, green_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

这就是上个笔记上的内容,存储两色区域的轮廓的

筛选for (const auto& contour : red_contours) {

            Rect rect = boundingRect(contour);

            if (rect.area() > 6200) {

                light_rect = rect;

                light_color = "Red";

                rectangle(resized_frame, rect, Scalar(0, 0, 255), 2);

            }

        }

        if (light_color == "Unknown") {

            for (const auto& contour : green_contours) {

                Rect rect = boundingRect(contour);

                if (rect.area() > 6950) {

                    light_rect = rect;

                    light_color = "Green";

                    rectangle(resized_frame, rect, Scalar(0, 255, 0), 2);

                }

其实前面还有两个light_color    light_rect的定义

上面计算外界矩形的面积,以过滤噪声轮廓

两个参数6200;6950,超级难调试,一会多了个红色,一会绿色一闪一闪的

以及最后的矩形标记

对于文字形式的呈现,由于前文已经弄了个light_color那末这里直接打上去就行了

putText(resized_frame, light_color, Point(10, 30),

                FONT_HERSHEY_SIMPLEX, 1, Scalar(255, 255, 255), 2);

最后呢,将每一帧加入视频即可

        writer.write(resized_frame);

        imshow("Traffic Light Detection", resized_frame);

大功告成

