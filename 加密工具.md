按照要求源文件和头文件应该是分成几个部分

Crypto.h /FileHandler.h/Menu.h

之后就是源文件Crypto.cpp/FileHandler.cpp/Meun.cpp(还有一个main.cpp)

为了使整个模块更加清晰有结构，我本来是打算根一些教程一样，将其分为三部分-----也就是CMakeLists.txt         src/     include/   这三部分

其中呢这个src/就是包含着头文件的文件夹（这部分是真难搞）然后include/是装着源文件的文件夹，确实这样子看起来是好看的，但由于我还不太熟练cmake的链接，所以我还是用朴素的方式来进行编写-------写一个头文件，写一个源文件，在写一个头文件........就这样，最后用main.cpp结尾

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760935334594-1b7d6fd9-8202-434d-bd5a-318671460dfb.jpeg)

在这上面用代码块表示有时会因为频繁拉动而麻烦，so，我用图片的形式展现出来，并附上这样编写的原因，这样子只用拉动鼠标即可阅览。

首先CMakeLists.txt的编写遵循流程，先确定最低版本（VERSION 3.10）

然后按要求生成CryptoTool的项目名称和使用语言

接下来为项目中所有目标设为c++11的标准，并使得标准成为强制性的（后续我用cmake编译时没报错，说明这个版本也可行）

接下来收集源文件，就是那四个

为收集头文件

生成可执行代码

ok，这就是较为简单的表达了

接下来弄Crypto

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760937504233-dde6a9d5-849e-43a8-b0c0-0f1fb26ad588.jpeg)

开头是普遍的头文件保护环节

包含字符串库

用到加密算法枚举类型，名称和值

定义类并私有访问(经过我的查找，之所以我看的教程中要私有访问，是为了防止外部随意更改，但我感觉其实对现在的我的代码都差不多没人会在意）之后再进行成员变量，用于存储当前的加密算法和密钥。

继续私有成员的函数声明（到时候用于输入信息），返回类型，函数名，参数啊实现算法。

然后公开后续要呈现的内容，此处按照考核要求要有两个变量参数，对应前文的算法类型和密钥两个

接下来从加密和解密两个接受返回

然后设置加密算法类型的方法实现修改变量的过程

设置密钥，同国内连实现，也是直接修改成员变量（比如说crypto.setKey(5);     进行修改

最后结束类定义并设置头文件保护



接下来是对应的源文件了

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760938482262-1b2b078f-bb4d-4eea-8a85-2c5fdeaff74d.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760938481890-892bc363-00bc-4b35-8f61-270bcd9f4c1d.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760938481248-d8c9ac28-68d3-4741-be9f-802f2b2b51f1.jpeg)

先是写的引用头文件（我算是明白之前学长们在群里说的以后要自己写头文件的意思了）以及一个字符处理函数的头文件

接下来是凯撒密码加密实现，创建空字符串存储后对偏移量取膜26,就是取余数，如果为负数则加到正数

之后用for 循环遍历字符，并判断大小写，接下来用公式表达凯撒密码核心算法：先将字符转化为0-25的数字，然后呢加上偏移量，并确保在取值范围内，最后加上基准回到ASCII的模式

代码进行解密过程（直接把上面的流程反转过来就行了）就是把+shift转变为-shift就行了

之后进行xor加密，依旧添加加密成员函数，且遍历输入字符串的每个字符

c ^ key 对字符串或者密钥进行异或运算

特别要注意：异或操作时有规律（c^key)^key=c



而因为有多种算法类型，so我用switch命令来匹配相适应的加密方法，case凯撒则调用凯撒加密，使用key作为偏移量，case  XOR则将key作为异或值，如果无，则返回原文

接下来统一解密接口，按上面的流程copy

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760950025427-359352a9-fda9-4348-8663-6482ed2fd834.jpeg)

文件操作类FileHandler.h

这个头文件就较为简单了

先保护，，加字符串库，类声明开始

首先由于本文件就是为其他代码提供文件操作服务，作为工具类，得公开才能被使用，如果变成私有的，其他代码就无法调用这些方法，因此用Pubilc

不需要创建类实例就可以调用，用静态方法，成功则返回文件内容字符串

写入文件名和内容，bool判断结果

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760950033262-23313488-34eb-45aa-afa6-d6080d4a0e96.jpeg)

文件操作实践

本来我只是弄了前一个头文件和输入输出的头文件，but发现根本写不下去，通过一顿搜索才得知文件操作怎么能少了最关键的读取和写入文件的方式呢，于是加了fstream这个头文件

接下来实现类的成员函数，固定常量，输入文件流以及输入的模式

判定文件是否成功打开，然后成功的话读取整个文件到字符串

writefile方法实现输出文件流，用于写入文件，然后输出

判定是否成功打开，成功后将整个字符串内容写入文件

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760955635668-c208173d-0859-4f5a-90d7-588c38f8e7ab.jpeg)

命令行菜单类（Menu.h)

这个文件就是集大成者了，包含着前两个头文件，有加密功能、文件操作功能，负责用户界面和程序流程的控制

私有就不多说了，仅内部使用，定义私有成员变量，加密对象默认时凯撒

从显示程序主菜单、处理用户输入的文本加密/解密、文件的加密/解密和选择类型，接下来进入公共模式，将成员初始化，定义状态

启动循环（void run )，结束类

中间其实出问题了好几次，我一点点修改，其中这最后也是忘记加类定义结束的代码的小错误

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760955653666-6af3e349-c689-4640-96db-959753962bdf.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760955656467-80440b46-0d56-4801-b604-c94ab3409606.jpeg)![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760955659859-7c8d6de1-b662-4959-9f04-66b787c5752c.jpeg)

菜单逻辑实现

ok，这是极为漫长的一步

在开头引用头文件之后我们进行两种加密方式的选择，接下来呈现多种操作的方案（即任务中要求的），文件加密、解密、文本加密、解密

之后用a来储存用户输入内容，选择加密方式

继续用文本加密的成员函数，我在这里是随便写的aaa,zzz,xxx函数名好记就行，不然我总是在过程中拼写错误这里相当与暂时存储用户输入的信息的位置，记录文件和key的变量（我想了想这个好像只能接受数字类型的，不过这也足以让程序运行起来了）设置密钥后，返回加密后的字符串

然后解密，存储待解密的文本，存储解密密钥，一样的流程，照葫芦画瓢得把文件加密、解密也写出来

最后!   主菜单循环run（）,判断程序是否正在运行（由用户选择）

用switch-case名伶，b为变量整合上述各类函数

```plain
void Menu::run() {
    int b;
    while (isRunning) {
        abc();
        std::cin >> b;
        switch (b) {
            case 1: qqq(); break;
            case 2: www(); break;
            case 3: zzz(); break;
            case 4: xxx(); break;
            case 5: def(); break;
            default: std::cout << "无效选项，请重新输入！" << std::endl; system("pause"); break;
        }
    }
}
```

一遍遍地运行函数，最后把这加入main.cpp中

![](https://cdn.nlark.com/yuque/0/2025/jpeg/61445279/1760955663160-df3b0148-8950-4caf-a802-8b88d3f3aaaf.jpeg)

最后mkdir build进入build，cmake ..，make就行了

总之呢，在这过程中难的是整体的任务框架，费事的事每个程序的任务编写，还总会报错，一遍遍得回看才能搞全











